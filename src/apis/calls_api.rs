/*
 * Vapi API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
pub use super::{Error, configuration, ContentType};
use serde_path_to_error;

/// struct for typed errors of method [`calls_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CallsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calls_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CallsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calls_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CallsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calls_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CallsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calls_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CallsUpdateError {
    UnknownValue(serde_json::Value),
}


// Recursive helper function to print a JSON Value as a tree
fn print_json_tree(value: &serde_json::Value, indent: usize) {
    let prefix = "  ".repeat(indent);

    match value {
        serde_json::Value::Object(map) => {
            for (k, v) in map {
                println!("{}{}:", prefix, k);
                print_json_tree(v, indent + 1);
            }
        }
        serde_json::Value::Array(arr) => {
            for (i, v) in arr.iter().enumerate() {
                println!("{}[{}]:", prefix, i);
                print_json_tree(v, indent + 1);
            }
        }
        _ => {
            // For scalar types (string, number, bool, null)
            println!("{}{:?}", prefix, value);
        }
    }
}

pub async fn calls_create(configuration: &configuration::Configuration, calls_create_request: models::CallsCreateRequest) -> Result<models::CallsCreateResponse, Error<CallsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_calls_create_request = calls_create_request;

    let uri_str = format!("{}/call", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_calls_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CallsCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CallsCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CallsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn calls_delete(configuration: &configuration::Configuration, id: &str) -> Result<models::Call, Error<CallsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/call/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Call`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Call`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CallsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn calls_get(configuration: &configuration::Configuration, id: &str) -> Result<models::Call, Error<CallsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/call/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Call`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Call`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CallsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn calls_list(configuration: &configuration::Configuration, id: Option<&str>, assistant_id: Option<&str>, phone_number_id: Option<&str>, limit: Option<f64>, created_at_gt: Option<String>, created_at_lt: Option<String>, created_at_ge: Option<String>, created_at_le: Option<String>, updated_at_gt: Option<String>, updated_at_lt: Option<String>, updated_at_ge: Option<String>, updated_at_le: Option<String>) -> Result<Vec<models::Call>, Error<CallsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_assistant_id = assistant_id;
    let p_phone_number_id = phone_number_id;
    let p_limit = limit;
    let p_created_at_gt = created_at_gt;
    let p_created_at_lt = created_at_lt;
    let p_created_at_ge = created_at_ge;
    let p_created_at_le = created_at_le;
    let p_updated_at_gt = updated_at_gt;
    let p_updated_at_lt = updated_at_lt;
    let p_updated_at_ge = updated_at_ge;
    let p_updated_at_le = updated_at_le;

    let uri_str = format!("{}/call", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_assistant_id {
        req_builder = req_builder.query(&[("assistantId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_phone_number_id {
        req_builder = req_builder.query(&[("phoneNumberId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_at_gt {
        req_builder = req_builder.query(&[("createdAtGt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_at_lt {
        req_builder = req_builder.query(&[("createdAtLt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_at_ge {
        req_builder = req_builder.query(&[("createdAtGe", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_at_le {
        req_builder = req_builder.query(&[("createdAtLe", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_at_gt {
        req_builder = req_builder.query(&[("updatedAtGt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_at_lt {
        req_builder = req_builder.query(&[("updatedAtLt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_at_ge {
        req_builder = req_builder.query(&[("updatedAtGe", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_at_le {
        req_builder = req_builder.query(&[("updatedAtLe", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    // Execute the request
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");

    let content_type = ContentType::from(content_type);
    let content = resp.text().await?;

    // If the HTTP status is not 4xx or 5xx, try to parse the success type.
    if !status.is_client_error() && !status.is_server_error() {
        if let ContentType::Json = content_type {
            // Try deserializing the entire JSON as `Vec<models::Call>`.
            match serde_json::from_str::<Vec<models::Call>>(&content) {
                Ok(calls) => Ok(calls),
                Err(e) => {
                    eprintln!("** Serde failed to parse response into `Vec<models::Call>` **");
                    eprintln!("Error: {}", e);

                    // Attempt to find the offending item by parsing into a generic Value:
                    if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&content) {
                        // If it’s an array, try each element individually.
                        if let serde_json::Value::Array(arr) = json_value {
                            eprintln!("Attempting to identify the exact failing item...");
                            for (index, item) in arr.iter().enumerate() {
                                let attempt = serde_json::from_value::<models::Call>(item.clone());
                                if let Err(parse_err) = attempt {
                                    eprintln!("\n--- Parse error at array index {} ---", index);
                                    eprintln!("Error: {}", parse_err);
                                    eprintln!("Offending item JSON:\n{}", item);
                                }
                            }
                        } else {
                            eprintln!("JSON root is not an array; full JSON:\n{}", json_value);
                        }
                    } else {
                        eprintln!("Could not parse the response as a JSON Value at all.");
                    }
                    // Return the original error
                    Err(Error::from(e))
                }
            }
        } else {
            // e.g. text/plain, or an unsupported content type
            return Err(Error::from(serde_json::Error::custom(
                format!(
                    "Received `{:?}` content type response that cannot be converted to `Vec<models::Call>`",
                    content_type
                ),
            )));
        }
    } else {
        // Handle 4xx/5xx by attempting to parse an error entity
        let entity: Option<CallsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn calls_update(configuration: &configuration::Configuration, id: &str, calls_update_request: models::CallsUpdateRequest) -> Result<models::Call, Error<CallsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_calls_update_request = calls_update_request;

    let uri_str = format!("{}/call/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_calls_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Call`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Call`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CallsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}